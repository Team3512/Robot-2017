diff --git a/changes.patch b/changes.patch
deleted file mode 100644
index 1045c1b..0000000
--- a/changes.patch
+++ /dev/null
@@ -1,1868 +0,0 @@
-diff --git a/src/AutonContainer.cpp b/src/AutonContainer.cpp
-deleted file mode 100644
-index 0b2ece1..0000000
---- a/src/AutonContainer.cpp
-+++ /dev/null
-@@ -1,30 +0,0 @@
--// Copyright (c) FRC Team 3512, Spartatroniks 2016-2017. All Rights Reserved.
--
--#include "AutonContainer.hpp"
--
--AutonMethod::AutonMethod(const std::string& methodName,
--                         std::function<void()> func) {
--    name = methodName;
--    function = func;
--}
--
--void AutonContainer::AddMethod(const std::string& methodName,
--                               std::function<void()> func) {
--    m_functionList.emplace_back(methodName, func);
--}
--
--void AutonContainer::DeleteAllMethods() { m_functionList.clear(); }
--
--size_t AutonContainer::Size() const { return m_functionList.size(); }
--
--const std::string& AutonContainer::Name(size_t pos) {
--    return m_functionList[pos].name;
--}
--
--void AutonContainer::ExecAutonomous(size_t pos) {
--    // Retrieves correct autonomous routine
--    auto& auton = m_functionList[pos];
--
--    // Runs the routine
--    (auton.function)();
--}
-diff --git a/src/AutonContainer.hpp b/src/AutonContainer.hpp
-deleted file mode 100644
-index 0303dad..0000000
---- a/src/AutonContainer.hpp
-+++ /dev/null
-@@ -1,37 +0,0 @@
--// Copyright (c) FRC Team 3512, Spartatroniks 2016-2017. All Rights Reserved.
--
--#pragma once
--
--#include <functional>
--#include <string>
--#include <vector>
--
--struct AutonMethod {
--    std::string name;
--    std::function<void()> function;
--
--    AutonMethod(const std::string& methodName, std::function<void()> func);
--};
--
--/**
-- * Stores Autonomous modes as function pointers for easy retrieval
-- */
--class AutonContainer {
--public:
--    // Add and remove autonomous functions
--    void AddMethod(const std::string& methodName, std::function<void()> func);
--    void DeleteAllMethods();
--
--    // Returns number of routines currently held
--    size_t Size() const;
--
--    // Returns name of specific autonomous function
--    const std::string& Name(size_t pos);
--
--    // Run specific autonomous function
--    void ExecAutonomous(size_t pos);
--
--private:
--    // Contains function pointers to the autonomous functions
--    std::vector<AutonMethod> m_functionList;
--};
-diff --git a/src/AutonomousModes/AutoDriveForward.cpp b/src/AutonomousModes/AutoDriveForward.cpp
-deleted file mode 100644
-index fec8525..0000000
---- a/src/AutonomousModes/AutoDriveForward.cpp
-+++ /dev/null
-@@ -1,12 +0,0 @@
--// Copyright (c) FRC Team 3512, Spartatroniks 2016-2017. All Rights Reserved.
--
--#include "../DigitalInputHandler.hpp"
--#include "../Robot.hpp"
--
--using namespace std::chrono_literals;
--
--// Drives forward
--void Robot::AutoDriveForward() {
--    Timer timer;
--    timer.Start();
--}
-diff --git a/src/AutonomousModes/AutoNoop.cpp b/src/AutonomousModes/AutoNoop.cpp
-deleted file mode 100644
-index b9c52ac..0000000
---- a/src/AutonomousModes/AutoNoop.cpp
-+++ /dev/null
-@@ -1,13 +0,0 @@
--// Copyright (c) FRC Team 3512, Spartatroniks 2016-2017. All Rights Reserved.
--
--#include "../Robot.hpp"
--
--using namespace std::chrono_literals;
--
--// Does nothing
--void Robot::AutoNoop() {
--    while (IsAutonomous() && IsEnabled()) {
--
--        std::this_thread::sleep_for(10ms);
--    }
--}
-diff --git a/src/DSDisplay.inl b/src/DSDisplay.inl
-deleted file mode 100644
-index 9e69ecf..0000000
---- a/src/DSDisplay.inl
-+++ /dev/null
-@@ -1,11 +0,0 @@
--// Copyright (c) FRC Team 3512, Spartatroniks 2016-2017. All Rights Reserved.
--
--#pragma once
--
--#include <string>
--
--template <class T>
--void DSDisplay::AddAutoMethod(const std::string& methodName,
--                              void (T::*function)(), T* object) {
--    m_autonModes.AddMethod(methodName, std::bind(function, object));
--}
-diff --git a/src/Robot.hpp b/src/Robot.hpp
-index f6ff890..9510446 100644
---- a/src/Robot.hpp
-+++ b/src/Robot.hpp
-@@ -13,9 +13,5 @@
- 
- class Robot : public SampleRobot {
- public:
--
--	void AutoDriveForward();
--	void AutoNoop();
--
- private:
- };
-diff --git a/src/SFML/Network/IpAddress.hpp b/src/SFML/Network/IpAddress.hpp
-deleted file mode 100644
-index b464eda..0000000
---- a/src/SFML/Network/IpAddress.hpp
-+++ /dev/null
-@@ -1,150 +0,0 @@
--////////////////////////////////////////////////////////////
--//
--// SFML - Simple and Fast Multimedia Library
--// Copyright (C) 2007-2012 Laurent Gomila (laurent.gom@gmail.com)
--//
--// This software is provided 'as-is', without any express or implied warranty.
--// In no event will the authors be held liable for any damages arising from the use of this software.
--//
--// Permission is granted to anyone to use this software for any purpose,
--// including commercial applications, and to alter it and redistribute it freely,
--// subject to the following restrictions:
--//
--// 1. The origin of this software must not be misrepresented;
--//    you must not claim that you wrote the original software.
--//    If you use this software in a product, an acknowledgment
--//    in the product documentation would be appreciated but is not required.
--//
--// 2. Altered source versions must be plainly marked as such,
--//    and must not be misrepresented as being the original software.
--//
--// 3. This notice may not be removed or altered from any source distribution.
--//
--////////////////////////////////////////////////////////////
--
--/* !!! THIS IS AN EXTREMELY ALTERED AND PURPOSE-BUILT VERSION OF SFML !!!
-- * This distribution is designed to possess only a limited subset of the
-- * original library's functionality and to only build on VxWorks 6.3.
-- * The original distribution of this software has many more features and
-- * supports more platforms.
-- */
--
--#ifndef SFML_IPADDRESS_HPP
--#define SFML_IPADDRESS_HPP
--
--#include <istream>
--#include <ostream>
--#include <string>
--
--namespace sf {
--class IpAddress {
--public:
--    IpAddress() = default;
--
--    /* The address can be either a decimal address (192.168.1.56) or a network
--     * name ("localhost")
--     */
--    IpAddress(const std::string& address);
--    IpAddress(const char* address);
--
--    /* Construct the address from 4 bytes
--     *
--     * Calling IpAddress(a, b, c, d) is equivalent to calling
--     * IpAddress("a.b.c.d"), but safer as it doesn't have to
--     * parse a string to get the address components.
--     */
--    IpAddress(uint8_t byte0, uint8_t byte1, uint8_t byte2, uint8_t byte3);
--
--    ////////////////////////////////////////////////////////////
--    /// \brief Construct the address from a 32-bits integer
--    ///
--    /// This constructor uses the internal representation of
--    /// the address directly. It should be used for optimization
--    /// purposes, and only if you got that representation from
--    /// IpAddress::ToInteger().
--    ///
--    /// \param address 4 bytes of the address packed into a 32-bits integer
--    ///
--    /// \see toInteger
--    ///
--    ////////////////////////////////////////////////////////////
--    explicit IpAddress(uint32_t address);
--
--    ////////////////////////////////////////////////////////////
--    /// \brief Get a string representation of the address
--    ///
--    /// The returned string is the decimal representation of the
--    /// IP address (like "192.168.1.56"), even if it was constructed
--    /// from a host name.
--    ///
--    /// \return String representation of the address
--    ///
--    /// \see toInteger
--    ///
--    ////////////////////////////////////////////////////////////
--    std::string toString() const;
--
--    ////////////////////////////////////////////////////////////
--    /// \brief Get an integer representation of the address
--    ///
--    /// The returned number is the internal representation of the
--    /// address, and should be used for optimization purposes only
--    /// (like sending the address through a socket).
--    /// The integer produced by this function can then be converted
--    /// back to a sf::IpAddress with the proper constructor.
--    ///
--    /// \return 32-bits unsigned integer representation of the address
--    ///
--    /// \see toString
--    ///
--    ////////////////////////////////////////////////////////////
--    uint32_t toInteger() const;
--
--    ////////////////////////////////////////////////////////////
--    /// \brief Get the computer's local address
--    ///
--    /// The local address is the address of the computer from the
--    /// LAN point of view, i.e. something like 192.168.1.56. It is
--    /// meaningful only for communications over the local network.
--    /// Unlike getPublicAddress, this function is fast and may be
--    /// used safely anywhere.
--    ///
--    /// \return Local IP address of the computer
--    ///
--    /// \see getPublicAddress
--    ///
--    ////////////////////////////////////////////////////////////
--    static IpAddress getLocalAddress();
--
--    static const IpAddress None;      ///< Value representing an empty/invalid address
--    static const IpAddress LocalHost; ///< The "localhost" address (for connecting a computer to itself locally)
--    static const IpAddress Broadcast; ///< The "broadcast" address (for sending UDP messages to everyone on a local network)
--
--private:
--    /* We're using 0 (INADDR_ANY) instead of INADDR_NONE to represent the
--     * invalid address because the latter is also the broadcast address
--     * (255.255.255.255); it's ok because SFML doesn't publicly use INADDR_ANY
--     * (it is always used implicitly)
--     */
--    uint32_t m_address = 0;
--};
--
--bool operator==(const IpAddress& left, const IpAddress& right);
--
--bool operator!=(const IpAddress& left, const IpAddress& right);
--
--bool operator<(const IpAddress& left, const IpAddress& right);
--
--bool operator>(const IpAddress& left, const IpAddress& right);
--
--bool operator<=(const IpAddress& left, const IpAddress& right);
--
--bool operator>=(const IpAddress& left, const IpAddress& right);
--
--std::istream& operator>>(std::istream& stream, IpAddress& address);
--
--std::ostream& operator<<(std::ostream& stream, const IpAddress& address);
--} // namespace sf
--
--
--#endif // SFML_IPADDRESS_HPP
-diff --git a/src/SFML/Network/Packet.hpp b/src/SFML/Network/Packet.hpp
-deleted file mode 100644
-index efe2868..0000000
---- a/src/SFML/Network/Packet.hpp
-+++ /dev/null
-@@ -1,222 +0,0 @@
--////////////////////////////////////////////////////////////
--//
--// SFML - Simple and Fast Multimedia Library
--// Copyright (C) 2007-2012 Laurent Gomila (laurent.gom@gmail.com)
--//
--// This software is provided 'as-is', without any express or implied warranty.
--// In no event will the authors be held liable for any damages arising from the use of this software.
--//
--// Permission is granted to anyone to use this software for any purpose,
--// including commercial applications, and to alter it and redistribute it freely,
--// subject to the following restrictions:
--//
--// 1. The origin of this software must not be misrepresented;
--//    you must not claim that you wrote the original software.
--//    If you use this software in a product, an acknowledgment
--//    in the product documentation would be appreciated but is not required.
--//
--// 2. Altered source versions must be plainly marked as such,
--//    and must not be misrepresented as being the original software.
--//
--// 3. This notice may not be removed or altered from any source distribution.
--//
--////////////////////////////////////////////////////////////
--
--/* !!! THIS IS AN EXTREMELY ALTERED AND PURPOSE-BUILT VERSION OF SFML !!!
-- * This distribution is designed to possess only a limited subset of the
-- * original library's functionality and to only build on VxWorks 6.3.
-- * The original distribution of this software has many more features and
-- * supports more platforms.
-- */
--
--#ifndef SFML_PACKET_HPP
--#define SFML_PACKET_HPP
--
--#include <stdint.h>
--
--#include <string>
--#include <vector>
--
--uint64_t htonll(uint64_t value);
--uint64_t ntohll(uint64_t value);
--
--namespace sf {
--class TcpSocket;
--class UdpSocket;
--
--////////////////////////////////////////////////////////////
--/// \brief Utility class to build blocks of data to transfer
--///        over the network
--///
--////////////////////////////////////////////////////////////
--class Packet {
--    // A bool-like type that cannot be converted to integer or pointer types
--    typedef bool (Packet::* BoolType)(std::size_t);
--
--public:
--    Packet() = default;
--
--    virtual ~Packet() = default;
--
--    // Append data to the end of the packet
--    void append(const void* data, std::size_t sizeInBytes);
--
--    // Empty the packet
--    void clear();
--
--    /* Get a pointer to the data contained in the packet
--     *
--     * Warning: the returned pointer may become invalid after you append data
--     * to the packet, therefore it should never be stored.
--     *
--     * The return pointer is nullptr if the packet is empty.
--     */
--    const void* getData() const;
--
--    /* Get the size of the data contained in the packet in bytes
--     *
--     * This function returns the number of bytes pointed to by what getData
--     * returns.
--     */
--    std::size_t getDataSize() const;
--
--    // Returns 'true' if reading position has reached end of the packet
--    bool endOfPacket() const;
--
--public:
--    ////////////////////////////////////////////////////////////
--    /// \brief Test the validity of the packet, for reading
--    ///
--    /// This operator allows to test the packet as a boolean
--    /// variable, to check if a reading operation was successful.
--    ///
--    /// A packet will be in an invalid state if it has no more
--    /// data to read.
--    ///
--    /// This behavior is the same as standard C++ streams.
--    ///
--    /// Usage example:
--    /// \code
--    /// float x;
--    /// packet >> x;
--    /// if (packet)
--    /// {
--    ///    // ok, x was extracted successfully
--    /// }
--    ///
--    /// // -- or --
--    ///
--    /// float x;
--    /// if (packet >> x)
--    /// {
--    ///    // ok, x was extracted successfully
--    /// }
--    /// \endcode
--    ///
--    /// Don't focus on the return type, it's equivalent to bool but
--    /// it disallows unwanted implicit conversions to integer or
--    /// pointer types.
--    ///
--    /// \return True if last data extraction from packet was successful
--    ///
--    /// \see endOfPacket
--    ///
--    ////////////////////////////////////////////////////////////
--    operator BoolType() const;
--
--    // Overloads of operator >> to read data from the packet
--    Packet& operator>>(bool&           data);
--    Packet& operator>>(int8_t&         data);
--    Packet& operator>>(uint8_t&        data);
--    Packet& operator>>(int16_t&        data);
--    Packet& operator>>(uint16_t&       data);
--    Packet& operator>>(int32_t&        data);
--    Packet& operator>>(uint32_t&       data);
--    Packet& operator>>(int64_t&        data);
--    Packet& operator>>(uint64_t&       data);
--    Packet& operator>>(float&          data);
--    Packet& operator>>(double&         data);
--    Packet& operator>>(char*           data);
--    Packet& operator>>(std::string&    data);
--    Packet& operator>>(wchar_t*        data);
--    Packet& operator>>(std::wstring&   data);
--
--    // Overloads of operator << to write data into the packet
--    Packet& operator<<(bool data);
--    Packet& operator<<(int8_t data);
--    Packet& operator<<(uint8_t data);
--    Packet& operator<<(int16_t data);
--    Packet& operator<<(uint16_t data);
--    Packet& operator<<(int32_t data);
--    Packet& operator<<(uint32_t data);
--    Packet& operator<<(int64_t data);
--    Packet& operator<<(uint64_t data);
--    Packet& operator<<(float data);
--    Packet& operator<<(double data);
--    Packet& operator<<(const char*           data);
--    Packet& operator<<(const std::string&    data);
--    Packet& operator<<(const wchar_t*        data);
--    Packet& operator<<(const std::wstring&   data);
--
--protected:
--    friend class TcpSocket;
--    friend class UdpSocket;
--
--    ////////////////////////////////////////////////////////////
--    /// \brief Called before the packet is sent over the network
--    ///
--    /// This function can be defined by derived classes to
--    /// transform the data before it is sent; this can be
--    /// used for compression, encryption, etc.
--    /// The function must return a pointer to the modified data,
--    /// as well as the number of bytes pointed.
--    /// The default implementation provides the packet's data
--    /// without transforming it.
--    ///
--    /// \param size Variable to fill with the size of data to send
--    ///
--    /// \return Pointer to the array of bytes to send
--    ///
--    /// \see onReceive
--    ///
--    ////////////////////////////////////////////////////////////
--    virtual const void* onSend(std::size_t& size);
--
--    ////////////////////////////////////////////////////////////
--    /// \brief Called after the packet is received over the network
--    ///
--    /// This function can be defined by derived classes to
--    /// transform the data after it is received; this can be
--    /// used for uncompression, decryption, etc.
--    /// The function receives a pointer to the received data,
--    /// and must fill the packet with the transformed bytes.
--    /// The default implementation fills the packet directly
--    /// without transforming the data.
--    ///
--    /// \param data Pointer to the received bytes
--    /// \param size Number of bytes
--    ///
--    /// \see onSend
--    ///
--    ////////////////////////////////////////////////////////////
--    virtual void onReceive(const void* data, std::size_t size);
--
--private:
--    // Disallow comparisons between packets
--    bool operator==(const Packet& right) const;
--    bool operator!=(const Packet& right) const;
--
--    /* Returns 'true' if the packet can extract a given number of bytes
--     *
--     * This function updates accordingly the state of the packet.
--     */
--    bool checkSize(std::size_t size);
--
--    std::vector<char> m_packetData;    ///< Data stored in the packet
--    std::size_t m_readPos = 0; ///< Current reading position in the packet
--    bool m_isValid = true; ///< Reading state of the packet
--};
--} // namespace sf
--
--
--#endif // SFML_PACKET_HPP
-diff --git a/src/SFML/Network/UdpSocket.hpp b/src/SFML/Network/UdpSocket.hpp
-deleted file mode 100644
-index b625d8c..0000000
---- a/src/SFML/Network/UdpSocket.hpp
-+++ /dev/null
-@@ -1,202 +0,0 @@
--////////////////////////////////////////////////////////////
--//
--// SFML - Simple and Fast Multimedia Library
--// Copyright (C) 2007-2012 Laurent Gomila (laurent.gom@gmail.com)
--//
--// This software is provided 'as-is', without any express or implied warranty.
--// In no event will the authors be held liable for any damages arising from the use of this software.
--//
--// Permission is granted to anyone to use this software for any purpose,
--// including commercial applications, and to alter it and redistribute it freely,
--// subject to the following restrictions:
--//
--// 1. The origin of this software must not be misrepresented;
--//    you must not claim that you wrote the original software.
--//    If you use this software in a product, an acknowledgment
--//    in the product documentation would be appreciated but is not required.
--//
--// 2. Altered source versions must be plainly marked as such,
--//    and must not be misrepresented as being the original software.
--//
--// 3. This notice may not be removed or altered from any source distribution.
--//
--////////////////////////////////////////////////////////////
--
--/* !!! THIS IS AN EXTREMELY ALTERED AND PURPOSE-BUILT VERSION OF SFML !!!
-- * This distribution is designed to possess only a limited subset of the
-- * original library's functionality and to only build on VxWorks 6.3.
-- * The original distribution of this software has many more features and
-- * supports more platforms.
-- */
--
--#ifndef SFML_UDPSOCKET_HPP
--#define SFML_UDPSOCKET_HPP
--
--#include <vector>
--
--#include "../../SFMLNetwork/Socket.hpp"
--
--namespace sf {
--class IpAddress;
--class Packet;
--
--////////////////////////////////////////////////////////////
--/// \brief Specialized socket using the UDP protocol
--///
--////////////////////////////////////////////////////////////
--class UdpSocket : public Socket {
--public:
--    ////////////////////////////////////////////////////////////
--    // Constants
--    ////////////////////////////////////////////////////////////
--    enum {
--        MaxDatagramSize = 65507 ///< The maximum number of bytes that can be sent in a single UDP datagram
--    };
--
--    ////////////////////////////////////////////////////////////
--    /// \brief Default constructor
--    ///
--    ////////////////////////////////////////////////////////////
--    UdpSocket();
--
--    ////////////////////////////////////////////////////////////
--    /// \brief Get the port to which the socket is bound locally
--    ///
--    /// If the socket is not bound to a port, this function
--    /// returns 0.
--    ///
--    /// \return Port to which the socket is bound
--    ///
--    /// \see bind
--    ///
--    ////////////////////////////////////////////////////////////
--    unsigned short getLocalPort() const;
--
--    ////////////////////////////////////////////////////////////
--    /// \brief Bind the socket to a specific port
--    ///
--    /// Binding the socket to a port is necessary for being
--    /// able to receive data on that port.
--    /// You can use the special value Socket::AnyPort to tell the
--    /// system to automatically pick an available port, and then
--    /// call getLocalPort to retrieve the chosen port.
--    ///
--    /// \param port Port to bind the socket to
--    ///
--    /// \return Status code
--    ///
--    /// \see unbind, getLocalPort
--    ///
--    ////////////////////////////////////////////////////////////
--    Status bind(unsigned short port);
--
--    ////////////////////////////////////////////////////////////
--    /// \brief Unbind the socket from the local port to which it is bound
--    ///
--    /// The port that the socket was previously using is immediately
--    /// available after this function is called. If the
--    /// socket is not bound to a port, this function has no effect.
--    ///
--    /// \see bind
--    ///
--    ////////////////////////////////////////////////////////////
--    void unbind();
--
--    ////////////////////////////////////////////////////////////
--    /// \brief Send raw data to a remote peer
--    ///
--    /// Make sure that \a size is not greater than
--    /// UdpSocket::MaxDatagramSize, otherwise this function will
--    /// fail and no data will be sent.
--    ///
--    /// \param data          Pointer to the sequence of bytes to send
--    /// \param size          Number of bytes to send
--    /// \param remoteAddress Address of the receiver
--    /// \param remotePort    Port of the receiver to send the data to
--    ///
--    /// \return Status code
--    ///
--    /// \see receive
--    ///
--    ////////////////////////////////////////////////////////////
--    Status send(const void* data,
--                std::size_t size,
--                const IpAddress& remoteAddress,
--                unsigned short remotePort);
--
--    ////////////////////////////////////////////////////////////
--    /// \brief Receive raw data from a remote peer
--    ///
--    /// In blocking mode, this function will wait until some
--    /// bytes are actually received.
--    /// Be careful to use a buffer which is large enough for
--    /// the data that you intend to receive, if it is too small
--    /// then an error will be returned and *all* the data will
--    /// be lost.
--    ///
--    /// \param data          Pointer to the array to fill with the received bytes
--    /// \param size          Maximum number of bytes that can be received
--    /// \param received      This variable is filled with the actual number of bytes received
--    /// \param remoteAddress Address of the peer that sent the data
--    /// \param remotePort    Port of the peer that sent the data
--    ///
--    /// \return Status code
--    ///
--    /// \see send
--    ///
--    ////////////////////////////////////////////////////////////
--    Status receive(void* data,
--                   std::size_t size,
--                   std::size_t& received,
--                   IpAddress& remoteAddress,
--                   unsigned short& remotePort);
--
--    ////////////////////////////////////////////////////////////
--    /// \brief Send a formatted packet of data to a remote peer
--    ///
--    /// Make sure that the packet size is not greater than
--    /// UdpSocket::MaxDatagramSize, otherwise this function will
--    /// fail and no data will be sent.
--    ///
--    /// \param packet        Packet to send
--    /// \param remoteAddress Address of the receiver
--    /// \param remotePort    Port of the receiver to send the data to
--    ///
--    /// \return Status code
--    ///
--    /// \see receive
--    ///
--    ////////////////////////////////////////////////////////////
--    Status send(Packet& packet,
--                const IpAddress& remoteAddress,
--                unsigned short remotePort);
--
--    ////////////////////////////////////////////////////////////
--    /// \brief Receive a formatted packet of data from a remote peer
--    ///
--    /// In blocking mode, this function will wait until the whole packet
--    /// has been received.
--    ///
--    /// \param packet        Packet to fill with the received data
--    /// \param remoteAddress Address of the peer that sent the data
--    /// \param remotePort    Port of the peer that sent the data
--    ///
--    /// \return Status code
--    ///
--    /// \see send
--    ///
--    ////////////////////////////////////////////////////////////
--    Status receive(Packet& packet,
--                   IpAddress& remoteAddress,
--                   unsigned short& remotePort);
--
--private:
--    ////////////////////////////////////////////////////////////
--    // Member data
--    ////////////////////////////////////////////////////////////
--    std::vector<char> m_buffer; ///< Temporary buffer holding the received data in Receive(Packet)
--};
--} // namespace sf
--
--
--#endif // SFML_UDPSOCKET_HPP
-diff --git a/src/SFMLNetwork/IpAddress.cpp b/src/SFMLNetwork/IpAddress.cpp
-deleted file mode 100644
-index fc8d7b1..0000000
---- a/src/SFMLNetwork/IpAddress.cpp
-+++ /dev/null
-@@ -1,167 +0,0 @@
--//
--// SFML - Simple and Fast Multimedia Library
--// Copyright (C) 2007-2012 Laurent Gomila (laurent.gom@gmail.com)
--//
--// This software is provided 'as-is', without any express or implied warranty.
--// In no event will the authors be held liable for any damages arising from the use of this software.
--//
--// Permission is granted to anyone to use this software for any purpose,
--// including commercial applications, and to alter it and redistribute it freely,
--// subject to the following restrictions:
--//
--// 1. The origin of this software must not be misrepresented;
--//    you must not claim that you wrote the original software.
--//    If you use this software in a product, an acknowledgment
--//    in the product documentation would be appreciated but is not required.
--//
--// 2. Altered source versions must be plainly marked as such,
--//    and must not be misrepresented as being the original software.
--//
--// 3. This notice may not be removed or altered from any source distribution.
--//
--
--#include "../SFML/Network/IpAddress.hpp"
--
--#include "Socket.hpp"
--
--namespace {
--uint32_t resolve(const std::string& address) {
--    if (address == "255.255.255.255") {
--        // The broadcast address needs to be handled explicitly,
--        // because it is also the value returned by inet_addr on error
--        return INADDR_BROADCAST;
--    }
--    else {
--        // Try to convert the address as a byte representation ("xxx.xxx.xxx.xxx")
--        uint32_t ip = inet_addr(const_cast<char*>(address.c_str()));
--        if (ip != INADDR_NONE) {
--            return ip;
--        }
--
--        // Not a valid address, try to convert it as a host name
--        hostent* host = gethostbyname(const_cast<char*>(address.c_str()));
--        if (host) {
--            return reinterpret_cast<in_addr*>(host->h_addr)->s_addr;
--        }
--
--        // Not a valid address nor a host name
--        return 0;
--    }
--}
--}
--
--
--namespace sf {
--const IpAddress IpAddress::None(0, 0, 0, 0);
--const IpAddress IpAddress::LocalHost(127, 0, 0, 1);
--const IpAddress IpAddress::Broadcast(255, 255, 255, 255);
--
--IpAddress::IpAddress(const std::string& address) :
--    m_address(resolve(address)) {
--}
--
--IpAddress::IpAddress(const char* address) :
--    m_address(resolve(address)) {
--}
--
--IpAddress::IpAddress(uint8_t byte0, uint8_t byte1, uint8_t byte2,
--                     uint8_t byte3) :
--    m_address(htonl(
--                  (byte0 << 24) | (byte1 << 16) | (byte2 << 8) |
--                  byte3)) {
--}
--
--IpAddress::IpAddress(uint32_t address) :
--    m_address(htonl(address)) {
--}
--
--std::string IpAddress::toString() const {
--    in_addr address;
--    address.s_addr = m_address;
--
--    return inet_ntoa(address);
--}
--
--
--
--uint32_t IpAddress::toInteger() const {
--    return ntohl(m_address);
--}
--
--
--
--IpAddress IpAddress::getLocalAddress() {
--    // The method here is to connect a UDP socket to anyone (here to localhost),
--    // and get the local socket address with the getsockname function.
--    // UDP connection will not send anything to the network, so this function won't cause any overhead.
--
--    IpAddress localAddress;
--
--    // Create the socket
--    int sock = socket(PF_INET, SOCK_DGRAM, 0);
--    if (sock == -1) {
--        return localAddress;
--    }
--
--    // Connect the socket to localhost on any port
--    sockaddr_in address = Socket::createAddress(ntohl(INADDR_LOOPBACK), 0);
--    if (connect(sock, reinterpret_cast<sockaddr*>(&address),
--                sizeof(address)) == -1) {
--        ::close(sock);
--        return localAddress;
--    }
--
--    // Get the local address of the socket connection
--    Socket::AddrLength size = sizeof(address);
--    socklen_t temp = size;
--    if (getsockname(sock, reinterpret_cast<sockaddr*>(&address),
--                    &temp) == -1) {
--        ::close(sock);
--        return localAddress;
--    }
--
--    // Close the socket
--    ::close(sock);
--
--    // Finally build the IP address
--    localAddress = IpAddress(ntohl(address.sin_addr.s_addr));
--
--    return localAddress;
--}
--
--bool operator==(const IpAddress& left, const IpAddress& right) {
--    return left.toInteger() == right.toInteger();
--}
--
--bool operator!=(const IpAddress& left, const IpAddress& right) {
--    return !(left == right);
--}
--
--bool operator<(const IpAddress& left, const IpAddress& right) {
--    return left.toInteger() < right.toInteger();
--}
--
--bool operator>(const IpAddress& left, const IpAddress& right) {
--    return right < left;
--}
--
--bool operator<=(const IpAddress& left, const IpAddress& right) {
--    return !(right < left);
--}
--
--bool operator>=(const IpAddress& left, const IpAddress& right) {
--    return !(left < right);
--}
--
--std::istream& operator>>(std::istream& stream, IpAddress& address) {
--    std::string str;
--    stream >> str;
--    address = IpAddress(str);
--
--    return stream;
--}
--
--std::ostream& operator<<(std::ostream& stream, const IpAddress& address) {
--    return stream << address.toString();
--}
--} // namespace sf
-diff --git a/src/SFMLNetwork/Packet.cpp b/src/SFMLNetwork/Packet.cpp
-deleted file mode 100644
-index 8bdda20..0000000
---- a/src/SFMLNetwork/Packet.cpp
-+++ /dev/null
-@@ -1,461 +0,0 @@
--////////////////////////////////////////////////////////////
--//
--// SFML - Simple and Fast Multimedia Library
--// Copyright (C) 2007-2012 Laurent Gomila (laurent.gom@gmail.com)
--//
--// This software is provided 'as-is', without any express or implied warranty.
--// In no event will the authors be held liable for any damages arising from the use of this software.
--//
--// Permission is granted to anyone to use this software for any purpose,
--// including commercial applications, and to alter it and redistribute it freely,
--// subject to the following restrictions:
--//
--// 1. The origin of this software must not be misrepresented;
--//    you must not claim that you wrote the original software.
--//    If you use this software in a product, an acknowledgment
--//    in the product documentation would be appreciated but is not required.
--//
--// 2. Altered source versions must be plainly marked as such,
--//    and must not be misrepresented as being the original software.
--//
--// 3. This notice may not be removed or altered from any source distribution.
--//
--////////////////////////////////////////////////////////////
--
--#include "../SFML/Network/Packet.hpp"
--
--#include <cstring>
--
--#include "Socket.hpp"
--
--uint64_t htonll(uint64_t value) {
--    // PowerPC for VxWorks 6.3 is big endian
--    return value;
--}
--
--uint64_t ntohll(uint64_t value) {
--    // PowerPC for VxWorks 6.3 is big endian
--    return value;
--}
--
--namespace sf {
--////////////////////////////////////////////////////////////
--void Packet::append(const void* data, std::size_t sizeInBytes) {
--    if (data && (sizeInBytes > 0)) {
--        std::size_t start = m_packetData.size();
--        m_packetData.resize(start + sizeInBytes);
--        std::memcpy(&m_packetData[start], data, sizeInBytes);
--    }
--}
--
--
--////////////////////////////////////////////////////////////
--void Packet::clear() {
--    m_packetData.clear();
--    m_readPos = 0;
--    m_isValid = true;
--}
--
--
--////////////////////////////////////////////////////////////
--const void* Packet::getData() const {
--    return !m_packetData.empty() ? &m_packetData[0] : nullptr;
--}
--
--
--////////////////////////////////////////////////////////////
--std::size_t Packet::getDataSize() const {
--    return m_packetData.size();
--}
--
--
--////////////////////////////////////////////////////////////
--bool Packet::endOfPacket() const {
--    return m_readPos >= m_packetData.size();
--}
--
--
--////////////////////////////////////////////////////////////
--Packet::operator BoolType() const {
--    return m_isValid ? &Packet::checkSize : nullptr;
--}
--
--
--////////////////////////////////////////////////////////////
--Packet& Packet::operator>>(bool& data) {
--    uint8_t value;
--    if (*this >> value) {
--        data = (value != 0);
--    }
--
--    return *this;
--}
--
--
--////////////////////////////////////////////////////////////
--Packet& Packet::operator>>(int8_t& data) {
--    if (checkSize(sizeof(data))) {
--        data = *reinterpret_cast<const int8_t*>(&m_packetData[m_readPos]);
--        m_readPos += sizeof(data);
--    }
--
--    return *this;
--}
--
--
--////////////////////////////////////////////////////////////
--Packet& Packet::operator>>(uint8_t& data) {
--    if (checkSize(sizeof(data))) {
--        data = *reinterpret_cast<const uint8_t*>(&m_packetData[m_readPos]);
--        m_readPos += sizeof(data);
--    }
--
--    return *this;
--}
--
--
--////////////////////////////////////////////////////////////
--Packet& Packet::operator>>(int16_t& data) {
--    if (checkSize(sizeof(data))) {
--        data =
--            ntohs(*reinterpret_cast<const int16_t*>(&m_packetData[m_readPos]));
--        m_readPos += sizeof(data);
--    }
--
--    return *this;
--}
--
--
--////////////////////////////////////////////////////////////
--Packet& Packet::operator>>(uint16_t& data) {
--    if (checkSize(sizeof(data))) {
--        data =
--            ntohs(
--                *reinterpret_cast<const uint16_t*>(&m_packetData[m_readPos]));
--        m_readPos += sizeof(data);
--    }
--
--    return *this;
--}
--
--
--////////////////////////////////////////////////////////////
--Packet& Packet::operator>>(int32_t& data) {
--    if (checkSize(sizeof(data))) {
--        data =
--            ntohl(*reinterpret_cast<const int32_t*>(&m_packetData[m_readPos]));
--        m_readPos += sizeof(data);
--    }
--
--    return *this;
--}
--
--
--////////////////////////////////////////////////////////////
--Packet& Packet::operator>>(uint32_t& data) {
--    if (checkSize(sizeof(data))) {
--        data =
--            ntohl(
--                *reinterpret_cast<const uint32_t*>(&m_packetData[m_readPos]));
--        m_readPos += sizeof(data);
--    }
--
--    return *this;
--}
--
--
--////////////////////////////////////////////////////////////
--Packet& Packet::operator>>(int64_t& data) {
--    if (checkSize(sizeof(data))) {
--        data =
--            ntohll(
--                *reinterpret_cast<const int64_t*>(&m_packetData[m_readPos]));
--        m_readPos += sizeof(data);
--    }
--
--    return *this;
--}
--
--
--////////////////////////////////////////////////////////////
--Packet& Packet::operator>>(uint64_t& data) {
--    if (checkSize(sizeof(data))) {
--        data =
--            ntohll(
--                *reinterpret_cast<const uint64_t*>(&m_packetData[m_readPos]));
--        m_readPos += sizeof(data);
--    }
--
--    return *this;
--}
--
--
--////////////////////////////////////////////////////////////
--Packet& Packet::operator>>(float& data) {
--    if (checkSize(sizeof(data))) {
--        data = *reinterpret_cast<const float*>(&m_packetData[m_readPos]);
--        m_readPos += sizeof(data);
--    }
--
--    return *this;
--}
--
--
--////////////////////////////////////////////////////////////
--Packet& Packet::operator>>(double& data) {
--    if (checkSize(sizeof(data))) {
--        data = *reinterpret_cast<const double*>(&m_packetData[m_readPos]);
--        m_readPos += sizeof(data);
--    }
--
--    return *this;
--}
--
--
--////////////////////////////////////////////////////////////
--Packet& Packet::operator>>(char* data) {
--    // First extract string length
--    uint32_t length = 0;
--    *this >> length;
--
--    if ((length > 0) && checkSize(length)) {
--        // Then extract characters
--        std::memcpy(data, &m_packetData[m_readPos], length);
--        data[length] = '\0';
--
--        // Update reading position
--        m_readPos += length;
--    }
--
--    return *this;
--}
--
--
--////////////////////////////////////////////////////////////
--Packet& Packet::operator>>(std::string& data) {
--    // First extract string length
--    uint32_t length = 0;
--    *this >> length;
--
--    data.clear();
--    if ((length > 0) && checkSize(length)) {
--        // Then extract characters
--        data.assign(&m_packetData[m_readPos], length);
--
--        // Update reading position
--        m_readPos += length;
--    }
--
--    return *this;
--}
--
--
--////////////////////////////////////////////////////////////
--Packet& Packet::operator>>(wchar_t* data) {
--    // First extract string length
--    uint32_t length = 0;
--    *this >> length;
--
--    if ((length > 0) && checkSize(length * sizeof(uint32_t))) {
--        // Then extract characters
--        for (uint32_t i = 0; i < length; ++i) {
--            uint32_t character = 0;
--            *this >> character;
--            data[i] = static_cast<wchar_t>(character);
--        }
--        data[length] = L'\0';
--    }
--
--    return *this;
--}
--
--
--////////////////////////////////////////////////////////////
--Packet& Packet::operator>>(std::wstring& data) {
--    // First extract string length
--    uint32_t length = 0;
--    *this >> length;
--
--    data.clear();
--    if ((length > 0) && checkSize(length * sizeof(uint32_t))) {
--        // Then extract characters
--        for (uint32_t i = 0; i < length; ++i) {
--            uint32_t character = 0;
--            *this >> character;
--            data += static_cast<wchar_t>(character);
--        }
--    }
--
--    return *this;
--}
--
--
--////////////////////////////////////////////////////////////
--Packet& Packet::operator<<(bool data) {
--    *this << static_cast<uint8_t>(data);
--    return *this;
--}
--
--
--////////////////////////////////////////////////////////////
--Packet& Packet::operator<<(int8_t data) {
--    append(&data, sizeof(data));
--    return *this;
--}
--
--
--////////////////////////////////////////////////////////////
--Packet& Packet::operator<<(uint8_t data) {
--    append(&data, sizeof(data));
--    return *this;
--}
--
--
--////////////////////////////////////////////////////////////
--Packet& Packet::operator<<(int16_t data) {
--    int16_t toWrite = htons(data);
--    append(&toWrite, sizeof(toWrite));
--    return *this;
--}
--
--
--////////////////////////////////////////////////////////////
--Packet& Packet::operator<<(uint16_t data) {
--    uint16_t toWrite = htons(data);
--    append(&toWrite, sizeof(toWrite));
--    return *this;
--}
--
--
--////////////////////////////////////////////////////////////
--Packet& Packet::operator<<(int32_t data) {
--    int32_t toWrite = htonl(data);
--    append(&toWrite, sizeof(toWrite));
--    return *this;
--}
--
--
--////////////////////////////////////////////////////////////
--Packet& Packet::operator<<(uint32_t data) {
--    uint32_t toWrite = htonl(data);
--    append(&toWrite, sizeof(toWrite));
--    return *this;
--}
--
--
--////////////////////////////////////////////////////////////
--Packet& Packet::operator<<(int64_t data) {
--    int64_t toWrite = htonll(data);
--    append(&toWrite, sizeof(toWrite));
--    return *this;
--}
--
--
--////////////////////////////////////////////////////////////
--Packet& Packet::operator<<(uint64_t data) {
--    uint64_t toWrite = htonll(data);
--    append(&toWrite, sizeof(toWrite));
--    return *this;
--}
--
--
--////////////////////////////////////////////////////////////
--Packet& Packet::operator<<(float data) {
--    append(&data, sizeof(data));
--    return *this;
--}
--
--
--////////////////////////////////////////////////////////////
--Packet& Packet::operator<<(double data) {
--    append(&data, sizeof(data));
--    return *this;
--}
--
--
--////////////////////////////////////////////////////////////
--Packet& Packet::operator<<(const char* data) {
--    // First insert string length
--    uint32_t length = 0;
--    for (const char* c = data; *c != '\0'; ++c) {
--        ++length;
--    }
--    *this << length;
--
--    // Then insert characters
--    append(data, length * sizeof(char));
--
--    return *this;
--}
--
--
--////////////////////////////////////////////////////////////
--Packet& Packet::operator<<(const std::string& data) {
--    // First insert string length
--    uint32_t length = static_cast<uint32_t>(data.size());
--    *this << length;
--
--    // Then insert characters
--    if (length > 0) {
--        append(data.c_str(), length * sizeof(std::string::value_type));
--    }
--
--    return *this;
--}
--
--
--////////////////////////////////////////////////////////////
--Packet& Packet::operator<<(const wchar_t* data) {
--    // First insert string length
--    uint32_t length = 0;
--    for (const wchar_t* c = data; *c != L'\0'; ++c) {
--        ++length;
--    }
--    *this << length;
--
--    // Then insert characters
--    for (const wchar_t* c = data; *c != L'\0'; ++c) {
--        *this << static_cast<uint32_t>(*c);
--    }
--
--    return *this;
--}
--
--
--////////////////////////////////////////////////////////////
--Packet& Packet::operator<<(const std::wstring& data) {
--    // First insert string length
--    uint32_t length = static_cast<uint32_t>(data.size());
--    *this << length;
--
--    // Then insert characters
--    if (length > 0) {
--        for (const auto& elem : data) {
--            *this << static_cast<uint32_t>(elem);
--        }
--    }
--
--    return *this;
--}
--
--
--////////////////////////////////////////////////////////////
--bool Packet::checkSize(std::size_t size) {
--    m_isValid = m_isValid && (m_readPos + size <= m_packetData.size());
--
--    return m_isValid;
--}
--
--
--////////////////////////////////////////////////////////////
--const void* Packet::onSend(std::size_t& size) {
--    size = getDataSize();
--    return getData();
--}
--
--
--////////////////////////////////////////////////////////////
--void Packet::onReceive(const void* data, std::size_t size) {
--    append(data, size);
--}
--} // namespace sf
-diff --git a/src/SFMLNetwork/Socket.cpp b/src/SFMLNetwork/Socket.cpp
-deleted file mode 100644
-index 9c7a44d..0000000
---- a/src/SFMLNetwork/Socket.cpp
-+++ /dev/null
-@@ -1,141 +0,0 @@
--////////////////////////////////////////////////////////////
--//
--// SFML - Simple and Fast Multimedia Library
--// Copyright (C) 2007-2012 Laurent Gomila (laurent.gom@gmail.com)
--//
--// This software is provided 'as-is', without any express or implied warranty.
--// In no event will the authors be held liable for any damages arising from the use of this software.
--//
--// Permission is granted to anyone to use this software for any purpose,
--// including commercial applications, and to alter it and redistribute it freely,
--// subject to the following restrictions:
--//
--// 1. The origin of this software must not be misrepresented;
--//    you must not claim that you wrote the original software.
--//    If you use this software in a product, an acknowledgment
--//    in the product documentation would be appreciated but is not required.
--//
--// 2. Altered source versions must be plainly marked as such,
--//    and must not be misrepresented as being the original software.
--//
--// 3. This notice may not be removed or altered from any source distribution.
--//
--////////////////////////////////////////////////////////////
--
--#include "Socket.hpp"
--
--#include <cstring>
--#include <iostream>
--
--#include <fcntl.h>
--
--namespace sf {
--Socket::Socket(Type sockType) :
--    m_socketType(sockType) {
--}
--
--Socket::~Socket() {
--    // Close the socket before it gets destructed
--    close();
--}
--
--void Socket::setBlocking(bool blocking) {
--    int status = fcntl(m_socket, F_GETFL);
--    if (blocking) {
--        fcntl(m_socket, F_SETFL, status & ~O_NONBLOCK);
--    }
--    else {
--        fcntl(m_socket, F_SETFL, status | O_NONBLOCK);
--    }
--
--    m_isBlocking = blocking;
--}
--
--bool Socket::isBlocking() const {
--    return m_isBlocking;
--}
--
--
--////////////////////////////////////////////////////////////
--int Socket::getHandle() const {
--    return m_socket;
--}
--
--void Socket::create() {
--    // Don't create the socket if it already exists
--    if (m_socket == -1) {
--        int handle = socket(PF_INET,
--                            m_socketType == Tcp ? SOCK_STREAM : SOCK_DGRAM,
--                            0);
--        create(handle);
--    }
--}
--
--void Socket::create(int handle) {
--    // Don't create the socket if it already exists
--    if (m_socket == -1) {
--        // Assign the new handle
--        m_socket = handle;
--
--        // Set the current blocking state
--        setBlocking(m_isBlocking);
--
--        if (m_socketType == Tcp) {
--            // Disable the Nagle algorithm (ie. removes buffering of TCP packets)
--            int yes = 1;
--            if (setsockopt(m_socket, IPPROTO_TCP, TCP_NODELAY,
--                           reinterpret_cast<char*>(&yes),
--                           sizeof(yes)) == -1) {
--                std::cerr << "Failed to set socket option \"TCP_NODELAY\" ; " <<
--                    "all your TCP packets will be buffered\n";
--            }
--        }
--        else {
--            // Enable broadcast by default for UDP sockets
--            int yes = 1;
--            if (setsockopt(m_socket, SOL_SOCKET, SO_BROADCAST,
--                           reinterpret_cast<char*>(&yes),
--                           sizeof(yes)) == -1) {
--                std::cerr << "Failed to enable broadcast on UDP socket\n";
--            }
--        }
--    }
--}
--
--void Socket::close() {
--    // Close the socket
--    if (m_socket != -1) {
--        ::close(m_socket);
--        m_socket = -1;
--    }
--}
--
--sockaddr_in Socket::createAddress(uint32_t address, unsigned short port) {
--    sockaddr_in addr;
--    std::memset(addr.sin_zero, 0, sizeof(addr.sin_zero));
--    addr.sin_addr.s_addr = htonl(address);
--    addr.sin_family      = AF_INET;
--    addr.sin_port        = htons(port);
--
--    return addr;
--}
--
--Socket::Status Socket::getErrorStatus() {
--    // The followings are sometimes equal to EWOULDBLOCK,
--    // so we have to make a special case for them in order
--    // to avoid having double values in the switch case
--    if ((errno == EAGAIN) || (errno == EINPROGRESS)) {
--        return Socket::NotReady;
--    }
--
--    switch (errno) {
--    case EWOULDBLOCK:  return Socket::NotReady;
--    case ECONNABORTED: return Socket::Disconnected;
--    case ECONNRESET:   return Socket::Disconnected;
--    case ETIMEDOUT:    return Socket::Disconnected;
--    case ENETRESET:    return Socket::Disconnected;
--    case ENOTCONN:     return Socket::Disconnected;
--    default:           return Socket::Error;
--    }
--}
--} // namespace sf
-diff --git a/src/SFMLNetwork/Socket.hpp b/src/SFMLNetwork/Socket.hpp
-deleted file mode 100644
-index 35fdd7f..0000000
---- a/src/SFMLNetwork/Socket.hpp
-+++ /dev/null
-@@ -1,137 +0,0 @@
--////////////////////////////////////////////////////////////
--//
--// SFML - Simple and Fast Multimedia Library
--// Copyright (C) 2007-2012 Laurent Gomila (laurent.gom@gmail.com)
--//
--// This software is provided 'as-is', without any express or implied warranty.
--// In no event will the authors be held liable for any damages arising from the use of this software.
--//
--// Permission is granted to anyone to use this software for any purpose,
--// including commercial applications, and to alter it and redistribute it freely,
--// subject to the following restrictions:
--//
--// 1. The origin of this software must not be misrepresented;
--//    you must not claim that you wrote the original software.
--//    If you use this software in a product, an acknowledgment
--//    in the product documentation would be appreciated but is not required.
--//
--// 2. Altered source versions must be plainly marked as such,
--//    and must not be misrepresented as being the original software.
--//
--// 3. This notice may not be removed or altered from any source distribution.
--//
--////////////////////////////////////////////////////////////
--
--/* !!! THIS IS AN EXTREMELY ALTERED AND PURPOSE-BUILT VERSION OF SFML !!!
-- * This distribution is designed to possess only a limited subset of the
-- * original library's functionality and to only build on VxWorks 6.3.
-- * The original distribution of this software has many more features and
-- * supports more platforms.
-- */
--
--#ifndef SFML_SOCKET_HPP
--#define SFML_SOCKET_HPP
--
--#include <vector>
--
--#include <arpa/inet.h>
--#include <netdb.h>
--#include <netinet/in.h>
--#include <netinet/tcp.h>
--#include <sys/socket.h>
--#include <sys/types.h>
--#include <unistd.h>
--
--namespace sf {
--class SocketSelector;
--
--////////////////////////////////////////////////////////////
--/// \brief Base class for all the socket types
--///
--////////////////////////////////////////////////////////////
--class Socket {
--public:
--    Socket(const Socket&) = delete;
--    Socket& operator=(const Socket) = delete;
--
--    friend class IpAddress;
--
--    typedef socklen_t AddrLength;
--
--    // Status codes that may be returned by socket functions
--    enum Status {
--        Done,         // The socket has sent / received the data
--        NotReady,     // The socket is not ready to send / receive data yet
--        Disconnected, // The TCP socket has been disconnected
--        Error         // An unexpected error happened
--    };
--
--    // Some special values used by sockets
--    enum {
--        AnyPort = 0 // Special value that tells the system to pick any available port
--    };
--
--    virtual ~Socket();
--
--    /* Set the blocking state of the socket
--     *
--     * In blocking mode, calls will not return until they have completed their
--     * task. For example, a call to Receive in blocking mode won't return until
--     * some data was actually received. In non-blocking mode, calls will always
--     * return immediately, using the return code to signal whether there was
--     * data available or not. By default, all sockets are blocking.
--     *
--     * 'true' = blocking
--     * 'false = non-blocking
--     */
--    void setBlocking(bool blocking);
--
--    /* Tell whether the socket is in blocking or non-blocking mode
--     * Returns 'true' if the socket is blocking, 'false' otherwise
--     */
--    bool isBlocking() const;
--
--protected:
--    // Types of protocols that the socket can use
--    enum Type {
--        Tcp, // TCP protocol
--        Udp  // UDP protocol
--    };
--
--    // This constructor can only be accessed by derived classes.
--    Socket(Type sockType);
--
--    // Return the handle of the socket
--    int getHandle() const;
--
--    // Create the internal representation of the socket
--    void create();
--
--    // Create the internal representation of the socket from a socket handle
--    void create(int handle);
--
--    // Close the socket gracefully
--    void close();
--
--    /* Create an internal sockaddr_in address
--     * Params:
--     *     address Target address
--     *     port    Target port
--     * Returns sockaddr_in ready to be used by socket functions
--     */
--    static sockaddr_in createAddress(uint32_t address, unsigned short port);
--
--    // Returns status corresponding to the last socket error
--    static Socket::Status getErrorStatus();
--
--private:
--    friend class SocketSelector;
--
--    Type m_socketType;
--    int m_socket{-1};      // Socket descriptor
--    bool m_isBlocking{true}; // Current blocking mode of the socket
--};
--} // namespace sf
--
--
--#endif // SFML_SOCKET_HPP
-diff --git a/src/SFMLNetwork/UdpSocket.cpp b/src/SFMLNetwork/UdpSocket.cpp
-deleted file mode 100644
-index 80f94a4..0000000
---- a/src/SFMLNetwork/UdpSocket.cpp
-+++ /dev/null
-@@ -1,193 +0,0 @@
--////////////////////////////////////////////////////////////
--//
--// SFML - Simple and Fast Multimedia Library
--// Copyright (C) 2007-2012 Laurent Gomila (laurent.gom@gmail.com)
--//
--// This software is provided 'as-is', without any express or implied warranty.
--// In no event will the authors be held liable for any damages arising from the use of this software.
--//
--// Permission is granted to anyone to use this software for any purpose,
--// including commercial applications, and to alter it and redistribute it freely,
--// subject to the following restrictions:
--//
--// 1. The origin of this software must not be misrepresented;
--//    you must not claim that you wrote the original software.
--//    If you use this software in a product, an acknowledgment
--//    in the product documentation would be appreciated but is not required.
--//
--// 2. Altered source versions must be plainly marked as such,
--//    and must not be misrepresented as being the original software.
--//
--// 3. This notice may not be removed or altered from any source distribution.
--//
--////////////////////////////////////////////////////////////
--
--#include "../SFML/Network/UdpSocket.hpp"
--
--#include <algorithm>
--#include <iostream>
--
--#include "../SFML/Network/IpAddress.hpp"
--#include "../SFML/Network/Packet.hpp"
--#include "Socket.hpp"
--
--namespace sf {
--UdpSocket::UdpSocket() :
--    Socket(Udp),
--    m_buffer(MaxDatagramSize) {
--}
--
--unsigned short UdpSocket::getLocalPort() const {
--    if (getHandle() != -1) {
--        // Retrieve informations about the local end of the socket
--        sockaddr_in address;
--        Socket::AddrLength size = sizeof(address);
--        socklen_t temp = size;
--        if (getsockname(getHandle(),
--                        reinterpret_cast<sockaddr*>(&address),
--                        &temp) != -1) {
--            return ntohs(address.sin_port);
--        }
--    }
--
--    // We failed to retrieve the port
--    return 0;
--}
--
--Socket::Status UdpSocket::bind(unsigned short port) {
--    // Create the internal socket if it doesn't exist
--    create();
--
--    // Bind the socket
--    sockaddr_in address = Socket::createAddress(INADDR_ANY, port);
--    if (::bind(getHandle(), reinterpret_cast<sockaddr*>(&address),
--               sizeof(address)) == -1) {
--        std::cerr << "Failed to bind socket to port " << port << "\n";
--        return Error;
--    }
--
--    return Done;
--}
--
--void UdpSocket::unbind() {
--    // Simply close the socket
--    close();
--}
--
--Socket::Status UdpSocket::send(const void* data,
--                               std::size_t size,
--                               const IpAddress& remoteAddress,
--                               unsigned short remotePort) {
--    // Create the internal socket if it doesn't exist
--    create();
--
--    // Make sure that all the data will fit in one datagram
--    if (size > MaxDatagramSize) {
--        std::cerr << "Cannot send data over the network "
--                  <<
--            "(the number of bytes to send is greater than sf::UdpSocket::MaxDatagramSize)\n";
--        return Error;
--    }
--
--    // Build the target address
--    sockaddr_in address = Socket::createAddress(
--        remoteAddress.toInteger(), remotePort);
--
--    // Send the data (unlike TCP, all the data is always sent in one call)
--    int sent =
--        sendto(
--            getHandle(), static_cast<char*>(const_cast<void*>(data)),
--            static_cast<int>(size), 0, reinterpret_cast<sockaddr*>(&address),
--            sizeof(address));
--
--    // Check for errors
--    if (sent < 0) {
--        return Socket::getErrorStatus();
--    }
--
--    return Done;
--}
--
--Socket::Status UdpSocket::receive(void* data,
--                                  std::size_t size,
--                                  std::size_t& received,
--                                  IpAddress& remoteAddress,
--                                  unsigned short& remotePort) {
--    // First clear the variables to fill
--    received      = 0;
--    remoteAddress = IpAddress();
--    remotePort    = 0;
--
--    // Check the destination buffer
--    if (!data) {
--        std::cerr <<
--            "Cannot receive data from the network (the destination buffer is invalid)\n";
--        return Error;
--    }
--
--    // Data that will be filled with the other computer's address
--    sockaddr_in address = Socket::createAddress(INADDR_ANY, 0);
--
--    // Receive a chunk of bytes
--    Socket::AddrLength addressSize = sizeof(address);
--    socklen_t temp = addressSize;
--    int sizeReceived =
--        recvfrom(
--            getHandle(), static_cast<char*>(const_cast<void*>(data)),
--            static_cast<int>(size), 0, reinterpret_cast<sockaddr*>(&address),
--            &temp);
--
--    // Check for errors
--    if (sizeReceived < 0) {
--        return Socket::getErrorStatus();
--    }
--
--    // Fill the sender informations
--    received      = static_cast<std::size_t>(sizeReceived);
--    remoteAddress = IpAddress(ntohl(address.sin_addr.s_addr));
--    remotePort    = ntohs(address.sin_port);
--
--    return Done;
--}
--
--Socket::Status UdpSocket::send(Packet& packet,
--                               const IpAddress& remoteAddress,
--                               unsigned short remotePort) {
--    /* UDP is a datagram-oriented protocol (as opposed to TCP which is a stream
--     * protocol). Sending one datagram is almost safe: it may be lost but if
--     * it's received, then its data is guaranteed to be ok. However, splitting
--     * a packet into multiple datagrams would be highly unreliable, since
--     * datagrams may be reordered, dropped or mixed between different sources.
--     * That's why SFML imposes a limit on packet size so that they can be sent
--     * in a single datagram. This also removes the overhead associated to
--     * packets -- there's no size to send in addition to the packet's data.
--     */
--
--    // Get the data to send from the packet
--    std::size_t size = 0;
--    const void* data = packet.onSend(size);
--
--    // Send it
--    return send(data, size, remoteAddress, remotePort);
--}
--
--Socket::Status UdpSocket::receive(Packet& packet,
--                                  IpAddress& remoteAddress,
--                                  unsigned short& remotePort) {
--    // See the detailed comment in send(Packet) above.
--
--    // Receive the datagram
--    std::size_t received = 0;
--    Status status = receive(&m_buffer[0],
--                            m_buffer.size(), received, remoteAddress,
--                            remotePort);
--
--    // If we received valid data, we can copy it to the user packet
--    packet.clear();
--    if ((status == Done) && (received > 0)) {
--        packet.onReceive(&m_buffer[0], received);
--    }
--
--    return status;
--}
--} // namespace sf
